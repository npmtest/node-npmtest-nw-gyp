{"/home/travis/build/npmtest/node-npmtest-nw-gyp/test.js":"/* istanbul instrument in package npmtest_nw_gyp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nw-gyp/lib.npmtest_nw_gyp.js":"/* istanbul instrument in package npmtest_nw_gyp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nw_gyp = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nw_gyp = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nw-gyp/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nw-gyp && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nw_gyp */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nw_gyp\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nw_gyp.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nw_gyp.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nw_gyp.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nw_gyp.__dirname + '/lib.npmtest_nw_gyp.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nw-gyp/node_modules/nw-gyp/lib/nw-gyp.js":"\n/**\n * Module exports.\n */\n\nmodule.exports = exports = gyp\n\n/**\n * Module dependencies.\n */\n\nvar fs = require('graceful-fs')\n  , path = require('path')\n  , nopt = require('nopt')\n  , log = require('npmlog')\n  , child_process = require('child_process')\n  , EE = require('events').EventEmitter\n  , inherits = require('util').inherits\n  , commands = [\n      // Module build commands\n        'build'\n      , 'clean'\n      , 'configure'\n      , 'rebuild'\n      // Development Header File management commands\n      , 'install'\n      , 'list'\n      , 'remove'\n    ]\n  , aliases = {\n        'ls': 'list'\n      , 'rm': 'remove'\n    }\n\n// differentiate node-gyp's logs from npm's\nlog.heading = 'gyp'\n\n/**\n * The `gyp` function.\n */\n\nfunction gyp () {\n  return new Gyp()\n}\n\nfunction Gyp () {\n  var self = this\n\n  this.commands = {}\n\n  commands.forEach(function (command) {\n    self.commands[command] = function (argv, callback) {\n      log.verbose('command', command, argv)\n      return require('./' + command)(self, argv, callback)\n    }\n  })\n}\ninherits(Gyp, EE)\nexports.Gyp = Gyp\nvar proto = Gyp.prototype\n\n/**\n * Export the contents of the package.json.\n */\n\nproto.package = require('../package')\n\n/**\n * nopt configuration definitions\n */\n\nproto.configDefs = {\n    help: Boolean     // everywhere\n  , devdir: String    // everywhere\n  , arch: String      // 'configure'\n  , cafile: String    // 'install'\n  , debug: Boolean    // 'build'\n  , directory: String // bin\n  , make: String      // 'build'\n  , msvs_version: String // 'configure'\n  , ensure: Boolean   // 'install'\n  , solution: String  // 'build' (windows only)\n  , proxy: String     // 'install'\n  , nodedir: String   // 'configure'\n  , loglevel: String  // everywhere\n  , python: String    // 'configure'\n  , 'dist-url': String // 'install'\n  , 'tarball': String // 'install'\n  , jobs: String      // 'build'\n  , thin: String      // 'configure'\n}\n\n/**\n * nopt shorthands\n */\n\nproto.shorthands = {\n    release: '--no-debug'\n  , C: '--directory'\n  , debug: '--debug'\n  , j: '--jobs'\n  , silly: '--loglevel=silly'\n  , verbose: '--loglevel=verbose'\n  , silent: '--loglevel=silent'\n}\n\n/**\n * expose the command aliases for the bin file to use.\n */\n\nproto.aliases = aliases\n\n/**\n * Parses the given argv array and sets the 'opts',\n * 'argv' and 'command' properties.\n */\n\nproto.parseArgv = function parseOpts (argv) {\n  this.opts = nopt(this.configDefs, this.shorthands, argv)\n  this.argv = this.opts.argv.remain.slice()\n\n  var commands = this.todo = []\n\n  // create a copy of the argv array with aliases mapped\n  argv = this.argv.map(function (arg) {\n    // is this an alias?\n    if (arg in this.aliases) {\n      arg = this.aliases[arg]\n    }\n    return arg\n  }, this)\n\n  // process the mapped args into \"command\" objects (\"name\" and \"args\" props)\n  argv.slice().forEach(function (arg) {\n    if (arg in this.commands) {\n      var args = argv.splice(0, argv.indexOf(arg))\n      argv.shift()\n      if (commands.length > 0) {\n        commands[commands.length - 1].args = args\n      }\n      commands.push({ name: arg, args: [] })\n    }\n  }, this)\n  if (commands.length > 0) {\n    commands[commands.length - 1].args = argv.splice(0)\n  }\n\n  // support for inheriting config env variables from npm\n  var npm_config_prefix = 'npm_config_'\n  Object.keys(process.env).forEach(function (name) {\n    if (name.indexOf(npm_config_prefix) !== 0) return\n    var val = process.env[name]\n    if (name === npm_config_prefix + 'loglevel') {\n      log.level = val\n    } else {\n      // add the user-defined options to the config\n      name = name.substring(npm_config_prefix.length)\n      // gyp@741b7f1 enters an infinite loop when it encounters\n      // zero-length options so ensure those don't get through.\n      if (name) this.opts[name] = val\n    }\n  }, this)\n\n  if (this.opts.loglevel) {\n    log.level = this.opts.loglevel\n  }\n  log.resume()\n\n  this.setupDevDir()\n}\n\n/**\n * Spawns a child process and emits a 'spawn' event.\n */\n\nproto.spawn = function spawn (command, args, opts) {\n  if (!opts) opts = {}\n  if (!opts.silent && !opts.stdio) {\n    opts.stdio = [ 0, 1, 2 ]\n  }\n  var cp = child_process.spawn(command, args, opts)\n  log.info('spawn', command)\n  log.info('spawn args', args)\n  return cp\n}\n\n/**\n * Returns the usage instructions for nw-gyp.\n */\n\nproto.usage = function usage () {\n  var str = [\n      ''\n    , '  Usage: nw-gyp <command> [options]'\n    , ''\n    , '  where <command> is one of:'\n    , commands.map(function (c) {\n        return '    - ' + c + ' - ' + require('./' + c).usage\n      }).join('\\n')\n    , ''\n    , 'nw-gyp@' + this.version + '  ' + path.resolve(__dirname, '..')\n    , 'node@' + process.versions.node\n  ].join('\\n')\n  return str\n}\n\n/**\n * Setup devdir attribute\n * By default devdir is set to `$HOME/.nw-gyp` unless passed with `--devdir`.\n */\nproto.setupDevDir = function() {\n  if (this.opts.devdir) {\n    this.devDir = this.opts.devdir\n    return\n  }\n\n  var homeDir = process.env.HOME || process.env.USERPROFILE\n  if (!homeDir) {\n    throw new Error(\n      \"nw-gyp requires --devdir parameter or the user's home directory is \" +\n      \"specified in either of the environmental variables HOME or USERPROFILE\"\n    )\n  }\n  this.devDir = path.resolve(homeDir, '.nw-gyp')\n}\n\n/**\n * Version number getter.\n */\n\nObject.defineProperty(proto, 'version', {\n    get: function () {\n      return this.package.version\n    }\n  , enumerable: true\n})\n\n","/home/travis/build/npmtest/node-npmtest-nw-gyp/node_modules/nw-gyp/bin/nw-gyp.js":"#!/usr/bin/env node\n\n/**\n * Set the title.\n */\n\nprocess.title = 'nw-gyp'\n\n/**\n * Module dependencies.\n */\n\nvar gyp = require('../')\nvar log = require('npmlog')\n\n/**\n * Process and execute the selected commands.\n */\n\nvar prog = gyp()\nvar completed = false\nprog.parseArgv(process.argv)\n\nif (prog.todo.length === 0) {\n  if (~process.argv.indexOf('-v') || ~process.argv.indexOf('--version')) {\n    console.log('v%s', prog.version)\n  } else {\n    console.log('%s', prog.usage())\n  }\n  return process.exit(0)\n}\n\nlog.info('it worked if it ends with', 'ok')\nlog.verbose('cli', process.argv)\nlog.info('using', 'nw-gyp@%s', prog.version)\nlog.info('using', 'node@%s | %s | %s', process.versions.node, process.platform, process.arch)\n\n\n/**\n * Change dir if -C/--directory was passed.\n */\n\nvar dir = prog.opts.directory\nif (dir) {\n  var fs = require('fs')\n  try {\n    var stat = fs.statSync(dir)\n    if (stat.isDirectory()) {\n      log.info('chdir', dir)\n      process.chdir(dir)\n    } else {\n      log.warn('chdir', dir + ' is not a directory')\n    }\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      log.warn('chdir', dir + ' is not a directory')\n    } else {\n      log.warn('chdir', 'error during chdir() \"%s\"', e.message)\n    }\n  }\n}\n\nfunction run () {\n  var command = prog.todo.shift()\n  if (!command) {\n    // done!\n    completed = true\n    log.info('ok')\n    return\n  }\n\n  prog.commands[command.name](command.args, function (err) {\n    if (err) {\n      log.error(command.name + ' error')\n      log.error('stack', err.stack)\n      errorMessage()\n      log.error('not ok')\n      return process.exit(1)\n    }\n    if (command.name == 'list') {\n      var versions = arguments[1]\n      if (versions.length > 0) {\n        versions.forEach(function (version) {\n          console.log(version)\n        })\n      } else {\n        console.log('No node development files installed. Use `nw-gyp install` to install a version.')\n      }\n    } else if (arguments.length >= 2) {\n      console.log.apply(console, [].slice.call(arguments, 1))\n    }\n\n    // now run the next command in the queue\n    process.nextTick(run)\n  })\n}\n\nprocess.on('exit', function (code) {\n  if (!completed && !code) {\n    log.error('Completion callback never invoked!')\n    issueMessage()\n    process.exit(6)\n  }\n})\n\nprocess.on('uncaughtException', function (err) {\n  log.error('UNCAUGHT EXCEPTION')\n  log.error('stack', err.stack)\n  issueMessage()\n  process.exit(7)\n})\n\nfunction errorMessage () {\n  // copied from npm's lib/util/error-handler.js\n  var os = require('os')\n  log.error('System', os.type() + ' ' + os.release())\n  log.error('command', process.argv\n            .map(JSON.stringify).join(' '))\n  log.error('cwd', process.cwd())\n  log.error('node -v', process.version)\n  log.error('nw-gyp -v', 'v' + prog.package.version)\n}\n\nfunction issueMessage () {\n  errorMessage()\n  log.error('', [ 'This is a bug in `nw-gyp`.'\n                , 'Try to update node-gyp and file an Issue if it does not help:'\n                , '    <https://github.com/nwjs/nw-gyp/issues>'\n                ].join('\\n'))\n}\n\n// start running the given commands!\nrun()\n","/home/travis/build/npmtest/node-npmtest-nw-gyp/node_modules/nw-gyp/lib/clean.js":"\nmodule.exports = exports = clean\n\nexports.usage = 'Removes any generated build files and the \"out\" dir'\n\n/**\n * Module dependencies.\n */\n\nvar rm = require('rimraf')\nvar log = require('npmlog')\n\n\nfunction clean (gyp, argv, callback) {\n\n  // Remove the 'build' dir\n  var buildDir = 'build'\n\n  log.verbose('clean', 'removing \"%s\" directory', buildDir)\n  rm(buildDir, callback)\n\n}\n","/home/travis/build/npmtest/node-npmtest-nw-gyp/node_modules/nw-gyp/lib/configure.js":"module.exports = exports = configure\nmodule.exports.test = { findAccessibleSync: findAccessibleSync, \n  findPython: findPython }\n\n/**\n * Module dependencies.\n */\n\nvar fs = require('graceful-fs')\n  , path = require('path')\n  , log = require('npmlog')\n  , osenv = require('osenv')\n  , which = require('which')\n  , semver = require('semver')\n  , mkdirp = require('mkdirp')\n  , cp = require('child_process')\n  , PathArray = require('path-array')\n  , extend = require('util')._extend\n  , processRelease = require('./nw-process-release')\n  , spawn = cp.spawn\n  , execFile = cp.execFile\n  , win = process.platform == 'win32'\n  , findNodeDirectory = require('./find-node-directory')\n  , msgFormat = require('util').format\n\nexports.usage = 'Generates ' + (win ? 'MSVC project files' : 'a Makefile') + ' for the current module'\n\nfunction configure (gyp, argv, callback) {\n\n  var python = gyp.opts.python || process.env.PYTHON || 'python2'\n    , buildDir = path.resolve('build')\n    , configNames = [ 'config.gypi', 'common.gypi' ]\n    , configs = []\n    , nodeDir\n    , release = processRelease(argv, gyp, process.version, process.release)\n    , isV13 = false\n\n  findPython(python, function (err, found) {\n    if (err) {\n      callback(err)\n    } else {\n      python = found\n      getNodeDir()\n    }\n  })\n\n  function getNodeDir () {\n\n    // 'python' should be set by now\n    process.env.PYTHON = python\n\n    if (gyp.opts.nodedir) {\n      // --nodedir was specified. use that for the dev files\n      nodeDir = gyp.opts.nodedir.replace(/^~/, osenv.home())\n\n      log.verbose('get node dir', 'compiling against specified --nodedir dev files: %s', nodeDir)\n      createBuildDir()\n\n    } else {\n      // if no --nodedir specified, ensure node dependencies are installed\n      if ('v' + release.version !== process.version) {\n        // if --target was given, then determine a target version to compile for\n        log.verbose('get node dir', 'compiling against --target node version: %s', release.version)\n      } else {\n        // if no --target was specified then use the current host node version\n        log.verbose('get node dir', 'no --target version specified, falling back to host node version: %s', release.version)\n      }\n\n      if (!release.semver) {\n        // could not parse the version string with semver\n        return callback(new Error('Invalid version number: ' + release.version))\n      }\n\n      // ensure that the target node version's dev files are installed\n      gyp.opts.ensure = true\n      gyp.commands.install([ release.version ], function (err, version) {\n        if (err) return callback(err)\n        log.verbose('get node dir', 'target node version installed:', release.versionDir)\n        nodeDir = path.resolve(gyp.devDir, release.versionDir)\n        createBuildDir()\n      })\n    }\n  }\n\n  function createBuildDir () {\n    log.verbose('build dir', 'attempting to create \"build\" dir: %s', buildDir)\n    mkdirp(buildDir, function (err, isNew) {\n      if (err) return callback(err)\n      log.verbose('build dir', '\"build\" dir needed to be created?', isNew)\n      createConfigFile()\n    })\n  }\n\n  function createConfigFile (err) {\n    if (err) return callback(err)\n\n    var configFilename = 'config.gypi'\n    var configPath = path.resolve(buildDir, configFilename)\n\n    log.verbose('build/' + configFilename, 'creating config file')\n\n    var config = process.config || {}\n      , defaults = config.target_defaults\n      , variables = config.variables\n\n    // default \"config.variables\"\n    if (!variables) variables = config.variables = {}\n\n    // default \"config.defaults\"\n    if (!defaults) defaults = config.target_defaults = {}\n\n    // don't inherit the \"defaults\" from node's `process.config` object.\n    // doing so could cause problems in cases where the `node` executable was\n    // compiled on a different machine (with different lib/include paths) than\n    // the machine where the addon is being built to\n    defaults.cflags = []\n    defaults.defines = []\n    defaults.include_dirs = []\n    defaults.libraries = []\n\n    // set the default_configuration prop\n    if ('debug' in gyp.opts) {\n      defaults.default_configuration = gyp.opts.debug ? 'Debug' : 'Release'\n    }\n    if (!defaults.default_configuration) {\n      defaults.default_configuration = 'Release'\n    }\n\n    // set the target_arch variable\n    var isLegacy = semver.lt(release.version, '0.11.0-rc1')\n    isV13 = semver.gt(release.version, '0.13.0-alpha0')\n\n    if (isLegacy && (process.platform == 'win32' || process.platform == 'darwin')) {\n      variables.target_arch = gyp.opts.arch || 'ia32'\n    } else\n      variables.target_arch = gyp.opts.arch || process.arch || 'ia32'\n\n    if (isLegacy && win) {\n      if (variables.target_arch != 'ia32') {\n        callback(new Error('Only 32bit libraries can be built on windows'))\n      }\n    }\n\n    // set the node development directory\n    variables.nodedir = nodeDir\n\n    // don't copy dev libraries with nodedir option\n    variables.copy_dev_lib = !gyp.opts.nodedir\n\n    // disable -T \"thin\" static archives by default\n    variables.standalone_static_library = gyp.opts.thin ? 0 : 1\n\n    // loop through the rest of the opts and add the unknown ones as variables.\n    // this allows for module-specific configure flags like:\n    //\n    //   $ node-gyp configure --shared-libxml2\n    Object.keys(gyp.opts).forEach(function (opt) {\n      if (opt === 'argv') return\n      if (opt in gyp.configDefs) return\n      variables[opt.replace(/-/g, '_')] = gyp.opts[opt]\n    })\n\n    // ensures that any boolean values from `process.config` get stringified\n    function boolsToString (k, v) {\n      if (typeof v === 'boolean')\n        return String(v)\n      return v\n    }\n\n    log.silly('build/' + configFilename, config)\n\n    // now write out the config.gypi file to the build/ dir\n    var prefix = '# Do not edit. File was generated by nw-gyp\\'s \"configure\" step'\n      , json = JSON.stringify(config, boolsToString, 2)\n    log.verbose('build/' + configFilename, 'writing out config file: %s', configPath)\n    configs.push(configPath)\n    fs.writeFile(configPath, [prefix, json, ''].join('\\n'), findConfigs)\n  }\n\n  function findConfigs (err) {\n    if (err) return callback(err)\n    var name = configNames.shift()\n    if (!name) return runGyp()\n    var fullPath = path.resolve(name)\n    log.verbose(name, 'checking for gypi file: %s', fullPath)\n    fs.stat(fullPath, function (err, stat) {\n      if (err) {\n        if (err.code == 'ENOENT') {\n          findConfigs() // check next gypi filename\n        } else {\n          callback(err)\n        }\n      } else {\n        log.verbose(name, 'found gypi file')\n        configs.push(fullPath)\n        findConfigs()\n      }\n    })\n  }\n\n  function runGyp (err) {\n    if (err) return callback(err)\n\n    if (!~argv.indexOf('-f') && !~argv.indexOf('--format')) {\n      if (win) {\n        log.verbose('gyp', 'gyp format was not specified; forcing \"msvs\"')\n        // force the 'make' target for non-Windows\n        argv.push('-f', 'msvs')\n      } else {\n        log.verbose('gyp', 'gyp format was not specified; forcing \"make\"')\n        // force the 'make' target for non-Windows\n        argv.push('-f', 'make')\n      }\n    }\n\n    function hasMsvsVersion () {\n      return argv.some(function (arg) {\n        return arg.indexOf('msvs_version') === 0\n      })\n    }\n\n    if (win && !hasMsvsVersion()) {\n      if ('msvs_version' in gyp.opts) {\n        argv.push('-G', 'msvs_version=' + gyp.opts.msvs_version)\n      } else {\n        argv.push('-G', 'msvs_version=auto')\n      }\n    }\n\n    // include all the \".gypi\" files that were found\n    configs.forEach(function (config) {\n      argv.push('-I', config)\n    })\n\n    // for AIX we need to set up the path to the exp file\n    // which contains the symbols needed for linking.\n    // The file will either be in one of the following\n    // depending on whether it is an installed or\n    // development environment:\n    //  - the include/node directory\n    //  - the out/Release directory\n    //  - the out/Debug directory\n    //  - the root directory\n    var node_exp_file = undefined\n    if (process.platform === 'aix') {\n      var node_root_dir = findNodeDirectory()\n      var candidates = ['include/node/node.exp',\n                        'out/Release/node.exp',\n                        'out/Debug/node.exp',\n                        'node.exp']\n      var logprefix = 'find exports file'\n      node_exp_file = findAccessibleSync(logprefix, node_root_dir, candidates)\n      if (node_exp_file !== undefined) {\n        log.verbose(logprefix, 'Found exports file: %s', node_exp_file)\n      } else {\n        var msg = msgFormat('Could not find node.exp file in %s', node_root_dir)\n        log.error(logprefix, 'Could not find exports file')\n        return callback(new Error(msg))\n      }\n    }\n\n    // this logic ported from the old `gyp_addon` python file\n    var gyp_script = path.resolve(__dirname, '..', 'gyp', 'gyp_main.py')\n    var addon_gypi = path.resolve(__dirname, '..', 'addon.gypi')\n    var common_gypi = path.resolve(nodeDir, 'include/node/common.gypi')\n    fs.stat(common_gypi, function (err, stat) {\n      if (err)\n        common_gypi = path.resolve(nodeDir, 'common.gypi')\n\n      var output_dir = 'build'\n      if (win) {\n        // Windows expects an absolute path\n        output_dir = buildDir\n      }\n      var nodeGypDir = path.resolve(__dirname, '..')\n\n      argv.push('-I', addon_gypi)\n      argv.push('-I', common_gypi)\n      argv.push('-Dlibrary=shared_library')\n      argv.push('-Dvisibility=default')\n      argv.push('-Dnode_root_dir=' + nodeDir)\n      if (process.platform === 'aix') {\n        argv.push('-Dnode_exp_file=' + node_exp_file)\n      }\n      argv.push('-Dnode_gyp_dir=' + nodeGypDir)\n      argv.push('-Dnode_lib_file=' + release.name + '.lib')\n      argv.push('-Dmodule_root_dir=' + process.cwd())\n      argv.push('--depth=.')\n      argv.push('--no-parallel')\n\n    if (isV13) {\n      log.verbose('gyp', 'build for v13')\n      argv.push('-Dv13=1')\n    } else {\n      argv.push('-Dv13=0')\n    }\n    // tell gyp to write the Makefile/Solution files into output_dir\n    argv.push('--generator-output', output_dir)\n\n      // tell make to write its output into the same dir\n      argv.push('-Goutput_dir=.')\n\n      // enforce use of the \"binding.gyp\" file\n      argv.unshift('binding.gyp')\n\n      // execute `gyp` from the current target nodedir\n      argv.unshift(gyp_script)\n\n      // make sure python uses files that came with this particular node package\n      var pypath = new PathArray(process.env, 'PYTHONPATH')\n      pypath.unshift(path.join(__dirname, '..', 'gyp', 'pylib'))\n\n      var cp = gyp.spawn(python, argv)\n      cp.on('exit', onCpExit)\n    })\n  }\n\n  /**\n   * Called when the `gyp` child process exits.\n   */\n\n  function onCpExit (code, signal) {\n    if (code !== 0) {\n      callback(new Error('`gyp` failed with exit code: ' + code))\n    } else {\n      // we're done\n      callback()\n    }\n  }\n\n}\n\n/**\n * Returns the first file or directory from an array of candidates that is \n * readable by the current user, or undefined if none of the candidates are\n * readable. \n */\nfunction findAccessibleSync (logprefix, dir, candidates) {\n  for (var next = 0; next < candidates.length; next++) {\n     var candidate = path.resolve(dir, candidates[next])\n     try {\n       var fd = fs.openSync(candidate, 'r')\n     } catch (e) {\n       // this candidate was not found or not readable, do nothing\n       log.silly(logprefix, 'Could not open %s: %s', candidate, e.message)\n       continue\n     }\n     fs.closeSync(fd)\n     log.silly(logprefix, 'Found readable %s', candidate)\n     return candidate\n  }\n\n  return undefined\n}\n\nfunction findPython (python, callback) {\n  checkPython()\n\n  // Check if Python is in the $PATH\n  function checkPython () {\n    log.verbose('check python', 'checking for Python executable \"%s\" in the PATH', python)\n    which(python, function (err, execPath) {\n      if (err) {\n        log.verbose('`which` failed', python, err)\n        if (python === 'python2') {\n          python = 'python'\n          return checkPython()\n        }\n        if (win) {\n          checkPythonLauncher()\n        } else {\n          failNoPython()\n        }\n      } else {\n        log.verbose('`which` succeeded', python, execPath)\n        // Found the `python` exceutable, and from now on we use it explicitly.\n        // This solves #667 and #750 (`execFile` won't run batch files\n        // (*.cmd, and *.bat))\n        python = execPath\n        checkPythonVersion()\n      }\n    })\n  }\n\n  // Distributions of Python on Windows by default install with the \"py.exe\"\n  // Python launcher which is more likely to exist than the Python executable\n  // being in the $PATH.\n  // Because the Python launcher supports all versions of Python, we have to\n  // explicitly request a Python 2 version. This is done by supplying \"-2\" as\n  // the first command line argument. Since \"py.exe -2\" would be an invalid\n  // executable for \"execFile\", we have to use the launcher to figure out\n  // where the actual \"python.exe\" executable is located.\n  function checkPythonLauncher () {\n    log.verbose('could not find \"' + python + '\". checking python launcher')\n    var env = extend({}, process.env)\n    env.TERM = 'dumb'\n\n    var launcherArgs = ['-2', '-c', 'import sys; print sys.executable']\n    execFile('py.exe', launcherArgs, { env: env }, function (err, stdout) {\n      if (err) {\n        guessPython()\n        return\n      }\n      python = stdout.trim()\n      log.verbose('check python launcher', 'python executable found: %j', python)\n      checkPythonVersion()\n    })\n  }\n\n  // Called on Windows when \"python\" isn't available in the current $PATH.\n  // We're gonna check if \"%SystemDrive%\\python27\\python.exe\" exists.\n  function guessPython () {\n    log.verbose('could not find \"' + python + '\". guessing location')\n    var rootDir = process.env.SystemDrive || 'C:\\\\'\n    if (rootDir[rootDir.length - 1] !== '\\\\') {\n      rootDir += '\\\\'\n    }\n    var pythonPath = path.resolve(rootDir, 'Python27', 'python.exe')\n    log.verbose('ensuring that file exists:', pythonPath)\n    fs.stat(pythonPath, function (err, stat) {\n      if (err) {\n        if (err.code == 'ENOENT') {\n          failNoPython()\n        } else {\n          callback(err)\n        }\n        return\n      }\n      python = pythonPath\n      checkPythonVersion()\n    })\n  }\n\n  function checkPythonVersion () {\n    var env = extend({}, process.env)\n    env.TERM = 'dumb'\n\n    execFile(python, ['-c', 'import platform; print(platform.python_version());'], { env: env }, function (err, stdout) {\n      if (err) {\n        return callback(err)\n      }\n      log.verbose('check python version', '`%s -c \"import platform; print(platform.python_version());\"` returned: %j', python, stdout)\n      var version = stdout.trim()\n      if (~version.indexOf('+')) {\n        log.silly('stripping \"+\" sign(s) from version')\n        version = version.replace(/\\+/g, '')\n      }\n      if (~version.indexOf('rc')) {\n        log.silly('stripping \"rc\" identifier from version')\n        version = version.replace(/rc(.*)$/ig, '')\n      }\n      var range = semver.Range('>=2.5.0 <3.0.0')\n      var valid = false\n      try {\n        valid = range.test(version)\n      } catch (e) {\n        log.silly('range.test() error', e)\n      }\n      if (valid) {\n        callback(null, python)\n      } else {\n        failPythonVersion(version)\n      }\n    })\n  }\n\n  function failNoPython () {\n    callback(new Error('Can\\'t find Python executable \"' + python +\n          '\", you can set the PYTHON env variable.'))\n  }\n\n  function failPythonVersion (badVersion) {\n    callback(new Error('Python executable \"' + python +\n          '\" is v' + badVersion + ', which is not supported by gyp.\\n' +\n          'You can pass the --python switch to point to Python >= v2.5.0 & < 3.0.0.'))\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-nw-gyp/node_modules/nw-gyp/lib/find-node-directory.js":"var path = require('path')\n  , log = require('npmlog')\n\nfunction findNodeDirectory(scriptLocation, processObj) {\n  // set dirname and process if not passed in\n  // this facilitates regression tests\n  if (scriptLocation === undefined) {\n    scriptLocation = __dirname\n  }\n  if (processObj === undefined) {\n    processObj = process\n  }\n\n  // Have a look to see what is above us, to try and work out where we are\n  npm_parent_directory = path.join(scriptLocation, '../../../..')\n  log.verbose('nw-gyp root', 'npm_parent_directory is '\n              + path.basename(npm_parent_directory))\n  node_root_dir = \"\"\n\n  log.verbose('nw-gyp root', 'Finding node root directory')\n  if (path.basename(npm_parent_directory) === 'deps') {\n    // We are in a build directory where this script lives in\n    // deps/npm/node_modules/node-gyp/lib\n    node_root_dir = path.join(npm_parent_directory, '..')\n    log.verbose('nw-gyp root', 'in build directory, root = '\n                + node_root_dir)\n  } else if (path.basename(npm_parent_directory) === 'node_modules') {\n    // We are in a node install directory where this script lives in\n    // lib/node_modules/npm/node_modules/node-gyp/lib or\n    // node_modules/npm/node_modules/node-gyp/lib depending on the\n    // platform\n    if (processObj.platform === 'win32') {\n      node_root_dir = path.join(npm_parent_directory, '..')\n    } else {\n      node_root_dir = path.join(npm_parent_directory, '../..')\n    }\n    log.verbose('nw-gyp root', 'in install directory, root = '\n                + node_root_dir)\n  } else {\n    // We don't know where we are, try working it out from the location\n    // of the node binary\n    var node_dir = path.dirname(processObj.execPath)\n    var directory_up = path.basename(node_dir)\n    if (directory_up === 'bin') {\n      node_root_dir = path.join(node_dir, '..')\n    } else if (directory_up === 'Release' || directory_up === 'Debug') {\n      // If we are a recently built node, and the directory structure\n      // is that of a repository. If we are on Windows then we only need\n      // to go one level up, everything else, two\n      if (processObj.platform === 'win32') {\n        node_root_dir = path.join(node_dir, '..')\n      } else {\n        node_root_dir = path.join(node_dir, '../..')\n      }\n    }\n    // Else return the default blank, \"\".\n  }\n  return node_root_dir\n}\n\nmodule.exports = findNodeDirectory\n","/home/travis/build/npmtest/node-npmtest-nw-gyp/node_modules/nw-gyp/lib/install.js":"\nmodule.exports = exports = install\n\nmodule.exports.test = { download: download, readCAFile: readCAFile }\n\nexports.usage = 'Install node development files for the specified node version.'\n\n/**\n * Module dependencies.\n */\n\nvar fs = require('graceful-fs')\n  , osenv = require('osenv')\n  , tar = require('tar')\n  , rm = require('rimraf')\n  , path = require('path')\n  , crypto = require('crypto')\n  , zlib = require('zlib')\n  , log = require('npmlog')\n  , semver = require('semver')\n  , fstream = require('fstream')\n  , request = require('request')\n  , minimatch = require('minimatch')\n  , mkdir = require('mkdirp')\n  , processRelease = require('./nw-process-release')\n  , win = process.platform == 'win32'\n\nfunction install (gyp, argv, callback) {\n\n  var release = processRelease(argv, gyp, process.version, process.release)\n\n  // ensure no double-callbacks happen\n  function cb (err) {\n    if (cb.done) return\n    cb.done = true\n    if (err) {\n      log.warn('install', 'got an error, rolling back install')\n      // roll-back the install if anything went wrong\n      gyp.commands.remove([ release.versionDir ], function (err2) {\n        callback(err)\n      })\n    } else {\n      callback(null, release.version)\n    }\n  }\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version)\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    return callback(new Error('Invalid version number: ' + release.version))\n  }\n\n  // \"legacy\" versions are < 0.11.0-rc1\n  var isLegacy = semver.lt(release.version, '0.11.0-rc1')\n  log.verbose('installing legacy version?', isLegacy)\n\n  var isV13 = semver.gt(release.version, '0.13.0-alpha0')\n\n  if (semver.lt(release.version, '0.3.2')) {\n    return callback(new Error('Minimum target version is `0.3.2` or greater. Got: ' + release.version))\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version)\n    if (gyp.opts.nodedir) {\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir)\n      callback()\n    } else {\n      callback(new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead'))\n    }\n    return\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir)\n\n  // the directory where the dev files will be installed\n  var devDir = path.resolve(gyp.devDir, release.versionDir)\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed')\n    fs.stat(devDir, function (err, stat) {\n      if (err) {\n        if (err.code == 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version)\n          go()\n        } else if (err.code == 'EACCES') {\n          eaccesFallback()\n        } else {\n          cb(err)\n        }\n        return\n      }\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"')\n      var installVersionFile = path.resolve(devDir, 'installVersion')\n      fs.readFile(installVersionFile, 'ascii', function (err, ver) {\n        if (err && err.code != 'ENOENT') {\n          return cb(err)\n        }\n        var installVersion = parseInt(ver, 10) || 0\n        log.verbose('got \"installVersion\"', installVersion)\n        log.verbose('needs \"installVersion\"', gyp.package.installVersion)\n        if (installVersion < gyp.package.installVersion) {\n          log.verbose('install', 'version is no good; reinstalling')\n          go()\n        } else {\n          log.verbose('install', 'version is good')\n          cb()\n        }\n      })\n    })\n  } else {\n    go()\n  }\n\n  function getContentSha(res, callback) {\n    var shasum = crypto.createHash('sha256')\n    res.on('data', function (chunk) {\n      shasum.update(chunk)\n    }).on('end', function () {\n      callback(null, shasum.digest('hex'))\n    })\n  }\n\n  function go () {\n\n    log.verbose('ensuring nodedir is created', devDir)\n\n    // first create the dir for the node dev files\n    mkdir(devDir, function (err, created) {\n      if (err) {\n        if (err.code == 'EACCES') {\n          eaccesFallback()\n        } else {\n          cb(err)\n        }\n        return\n      }\n\n      if (created) {\n        log.verbose('created nodedir', created)\n      }\n\n      // now download the node tarball\n      var tarPath = gyp.opts.tarball\n      var badDownload = false\n        , extractCount = 0\n        , gunzip = zlib.createGunzip()\n        , extracter = tar.Extract({ path: devDir, strip: 1, filter: isValid })\n\n      var contentShasums = {}\n      var expectShasums = {}\n\n      // checks if a file to be extracted from the tarball is valid.\n      // only .h header files and the gyp files get extracted\n      function isValid () {\n        var name = this.path.substring(devDir.length + 1)\n        var isValid = valid(name)\n        if (name === '' && this.type === 'Directory') {\n          // the first directory entry is ok\n          return true\n        }\n        if (isValid) {\n          log.verbose('extracted file from tarball', name)\n          extractCount++\n        } else {\n          // invalid\n          log.silly('ignoring from tarball', name)\n        }\n        return isValid\n      }\n\n      gunzip.on('error', cb)\n      extracter.on('error', cb)\n      extracter.on('end', afterTarball)\n\n      // download the tarball, gunzip and extract!\n\n      if (tarPath) {\n        var input = fs.createReadStream(tarPath)\n        input.pipe(gunzip).pipe(extracter)\n        return\n      }\n\n      try {\n        var req = download(gyp, process.env, release.tarballUrl)\n      } catch (e) {\n        return cb(e)\n      }\n\n      // something went wrong downloading the tarball?\n      req.on('error', function (err) {\n        if (err.code === 'ENOTFOUND') {\n          return cb(new Error('This is most likely not a problem with nw-gyp or the package itself and\\n' +\n            'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' +\n            'network settings.'))\n        }\n        badDownload = true\n        cb(err)\n      })\n\n      req.on('close', function () {\n        if (extractCount === 0) {\n          cb(new Error('Connection closed while downloading tarball file'))\n        }\n      })\n\n      req.on('response', function (res) {\n        if (res.statusCode !== 200) {\n          badDownload = true\n          cb(new Error(res.statusCode + ' response downloading ' + release.tarballUrl))\n          return\n        }\n        // content checksum\n        getContentSha(res, function (_, checksum) {\n          var filename = path.basename(release.tarballUrl).trim()\n          contentShasums[filename] = checksum\n          log.verbose('content checksum', filename, checksum)\n        })\n\n        // start unzipping and untaring\n        req.pipe(gunzip).pipe(extracter)\n      })\n\n      // invoked after the tarball has finished being extracted\n      function afterTarball () {\n        if (badDownload) return\n        if (extractCount === 0) {\n          return cb(new Error('There was a fatal problem while downloading/extracting the tarball'))\n        }\n        log.verbose('tarball', 'done parsing tarball')\n        var async = 0\n\n        if (win) {\n          // need to download node.lib\n          async++\n          downloadNodeLib(deref)\n        }\n\n        // write the \"installVersion\" file\n        async++\n        var installVersionPath = path.resolve(devDir, 'installVersion')\n        fs.writeFile(installVersionPath, gyp.package.installVersion + '\\n', deref)\n\n/*\n        // Only download SHASUMS.txt if not using tarPath override\n        if (!tarPath) {\n          // download SHASUMS.txt\n          async++\n          downloadShasums(deref)\n        }\n*/\n        if (async === 0) {\n          // no async tasks required\n          cb()\n        }\n\n        function deref (err) {\n          if (err) return cb(err)\n\n          async--\n          if (!async) {\n/*\n            log.verbose('download contents checksum', JSON.stringify(contentShasums))\n            // check content shasums\n            for (var k in contentShasums) {\n              log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k])\n              if (contentShasums[k] !== expectShasums[k]) {\n                cb(new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]))\n                return\n              }\n            }\n*/\n            cb()\n          }\n        }\n      }\n\n      function downloadShasums(done) {\n        log.verbose('check download content checksum, need to download `SHASUMS256.txt`...')\n        var shasumsPath = path.resolve(devDir, 'SHASUMS256.txt')\n\n        log.verbose('checksum url', release.shasumsUrl)\n        try {\n          var req = download(gyp, process.env, release.shasumsUrl)\n        } catch (e) {\n          return cb(e)\n        }\n\n        req.on('error', done)\n        req.on('response', function (res) {\n          if (res.statusCode !== 200) {\n            done(new Error(res.statusCode + ' status code downloading checksum'))\n            return\n          }\n\n          var chunks = []\n          res.on('data', function (chunk) {\n            chunks.push(chunk)\n          })\n          res.on('end', function () {\n            var lines = Buffer.concat(chunks).toString().trim().split('\\n')\n            lines.forEach(function (line) {\n              var items = line.trim().split(/\\s+/)\n              if (items.length !== 2) return\n\n              // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n              var name = items[1].replace(/^\\.\\//, '')\n              expectShasums[name] = items[0]\n            })\n\n            log.verbose('checksum data', JSON.stringify(expectShasums))\n            done()\n          })\n        })\n      }\n\n      function downloadNodeLib (done) {\n        log.verbose('on Windows; need to download `nw.lib`...')\n        var dir32 = path.resolve(devDir, 'ia32')\n          , dir64 = path.resolve(devDir, 'x64')\n          , nodeLibPath32 = path.resolve(dir32, 'node.lib')\n          , nodeLibPath64 = path.resolve(dir64, 'node.lib')\n          , libPath32 = path.resolve(dir32, 'nw.lib')\n          , libPath64 = path.resolve(dir64, 'nw.lib')\n\n        log.verbose('32-bit nw.lib dir', dir32)\n        log.verbose('64-bit nw.lib dir', dir64)\n        log.verbose('`nw.lib` 32-bit url', release.libUrl32)\n        log.verbose('`nw.lib` 64-bit url', release.libUrl64)\n\n        var async = isLegacy ? 1 : 2;\n        async = isV13 ? 4 : async;\n\n        mkdir(dir32, function (err) {\n          if (err) return done(err)\n          log.verbose('streaming 32-bit nw.lib to:', libPath32)\n\n          try {\n            var req = download(gyp, process.env, release.libUrl32, cb)\n          } catch (e) {\n            return cb(e)\n          }\n\n          req.on('error', done)\n          req.on('response', function (res) {\n            if (res.statusCode !== 200) {\n              done(new Error(res.statusCode + ' status code downloading 32-bit nw.lib'))\n              return\n            }\n\n            getContentSha(res, function (_, checksum) {\n              contentShasums[release.libPath32] = checksum\n              log.verbose('content checksum', release.libPath32, checksum)\n            })\n\n            var ws = fs.createWriteStream(libPath32)\n            ws.on('error', cb)\n            req.pipe(ws)\n          })\n          req.on('end', function () {\n            --async || done()\n          })\n        })\n\n        if (!isLegacy) {\n          mkdir(dir64, function (err) {\n            if (err) return done(err)\n            log.verbose('streaming 64-bit nw.lib to:', libPath64)\n\n            try {\n              var req = download(gyp, process.env, release.libUrl64, cb)\n            } catch (e) {\n              return cb(e)\n            }\n\n            req.on('error', done)\n            req.on('response', function (res) {\n              if (res.statusCode !== 200) {\n                done(new Error(res.statusCode + ' status code downloading 64-bit nw.lib'))\n                return\n              }\n\n              getContentSha(res, function (_, checksum) {\n                contentShasums[release.libPath64] = checksum\n                log.verbose('content checksum', release.libPath64, checksum)\n              })\n\n              var ws = fs.createWriteStream(libPath64)\n              ws.on('error', cb)\n              req.pipe(ws)\n            })\n            req.on('end', function () {\n              --async || done()\n            })\n          })\n        } // isLegacy\n\n        if (isV13) {\n\n          log.verbose('on Windows; need to download `node.lib`...')\n\n          log.verbose('32-bit node.lib dir', dir32)\n          log.verbose('64-bit node.lib dir', dir64)\n          log.verbose('`node.lib` 32-bit url', release.nodeLibUrl32)\n          log.verbose('`node.lib` 64-bit url', release.nodeLibUrl64)\n\n          mkdir(dir32, function (err) {\n            if (err) return done(err)\n            log.verbose('streaming 32-bit node.lib to:', nodeLibPath32)\n\n            try {\n              var req = download(gyp, process.env, release.nodeLibUrl32, cb)\n            } catch (e) {\n              return cb(e)\n            }\n\n            req.on('error', done)\n            req.on('response', function (res) {\n              if (res.statusCode !== 200) {\n                done(new Error(res.statusCode + ' status code downloading 32-bit node.lib'))\n                return\n              }\n\n              getContentSha(res, function (_, checksum) {\n                contentShasums[release.nodeLibPath32] = checksum\n                log.verbose('content checksum', release.nodeLibPath32, checksum)\n              })\n\n              var ws = fs.createWriteStream(nodeLibPath32)\n              ws.on('error', cb)\n              req.pipe(ws)\n            })\n            req.on('end', function () {\n              --async || done()\n            })\n          })\n          mkdir(dir64, function (err) {\n            if (err) return done(err)\n            log.verbose('streaming 64-bit node.lib to:', nodeLibPath64)\n\n            try {\n              var req = download(gyp, process.env, release.nodeLibUrl64, cb)\n            } catch (e) {\n              return cb(e)\n            }\n\n            req.on('error', done)\n            req.on('response', function (res) {\n              if (res.statusCode !== 200) {\n                done(new Error(res.statusCode + ' status code downloading 64-bit node.lib'))\n                return\n              }\n\n              getContentSha(res, function (_, checksum) {\n                contentShasums[release.nodeLibPath64] = checksum\n                log.verbose('content checksum', release.nodeLibPath64, checksum)\n              })\n\n              var ws = fs.createWriteStream(nodeLibPath64)\n              ws.on('error', cb)\n              req.pipe(ws)\n            })\n            req.on('end', function () {\n              --async || done()\n            })\n          })\n        } // V13\n      } // downloadNodeLib()\n\n    }) // mkdir()\n\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid (file) {\n    // header files\n    return minimatch(file, '*.h', { matchBase: true }) ||\n           minimatch(file, '*.gypi', { matchBase: true })\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  function eaccesFallback () {\n    var tmpdir = osenv.tmpdir()\n    gyp.devDir = path.resolve(tmpdir, '.nw-gyp')\n    log.warn('EACCES', 'user \"%s\" does not have permission to access the dev dir \"%s\"', osenv.user(), devDir)\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir)\n    if (process.cwd() == tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space')\n      gyp.todo.push({ name: 'remove', args: argv })\n    }\n    gyp.commands.install(argv, cb)\n  }\n\n}\n\nfunction download (gyp, env, url) {\n  log.http('GET', url)\n\n  var requestOpts = {\n      uri: url\n    , headers: {\n        'User-Agent': 'node-gyp v' + gyp.version + ' (node ' + process.version + ')'\n      }\n  }\n\n  var cafile = gyp.opts.cafile\n  if (cafile) {\n    requestOpts.ca = readCAFile(cafile)\n  }\n\n  // basic support for a proxy server\n  var proxyUrl = gyp.opts.proxy\n              || env.http_proxy\n              || env.HTTP_PROXY\n              || env.npm_config_proxy\n  if (proxyUrl) {\n    if (/^https?:\\/\\//i.test(proxyUrl)) {\n      log.verbose('download', 'using proxy url: \"%s\"', proxyUrl)\n      requestOpts.proxy = proxyUrl\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl)\n    }\n  }\n\n  var req = request(requestOpts)\n  req.on('response', function (res) {\n    log.http(res.statusCode, url)\n  })\n\n  return req\n}\n\nfunction readCAFile (filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  var ca = fs.readFileSync(filename, 'utf8')\n  var re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g\n  return ca.match(re)\n}\n","/home/travis/build/npmtest/node-npmtest-nw-gyp/node_modules/nw-gyp/lib/list.js":"\nmodule.exports = exports = list\n\nexports.usage = 'Prints a listing of the currently installed node development files'\n\n/**\n * Module dependencies.\n */\n\nvar fs = require('graceful-fs')\n  , path = require('path')\n  , log = require('npmlog')\n\nfunction list (gyp, args, callback) {\n\n  var devDir = gyp.devDir\n  log.verbose('list', 'using nw-gyp dir:', devDir)\n\n  // readdir() the node-gyp dir\n  fs.readdir(devDir, onreaddir)\n\n  function onreaddir (err, versions) {\n    if (err && err.code != 'ENOENT') {\n      return callback(err)\n    }\n    if (Array.isArray(versions)) {\n      versions = versions.filter(function (v) { return v != 'current' })\n    } else {\n      versions = []\n    }\n    callback(null, versions)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-nw-gyp/node_modules/nw-gyp/lib/nw-process-release.js":"var semver = require('semver')\n  , url = require('url')\n  , path = require('path')\n\n// Captures all the logic required to determine download URLs, local directory and \n// file names. Inputs come from command-line switches (--target, --dist-url).\nfunction processRelease (argv, gyp/*, defaultVersion, defaultRelease*/) {\n  // nw-gyp: `defaultVersion` and `defaultRelease` are meaningless for NW.js\n  var version = (semver.valid(argv[0]) && argv[0]) || gyp.opts.target\n    , versionSemver = semver.parse(version)\n    , overrideDistUrl = gyp.opts['dist-url'] || gyp.opts.disturl\n    , distBaseUrl\n    , baseUrl\n    , libUrl32\n    , libUrl64\n    , nodeLibUrl32\n    , nodeLibUrl32\n    , tarballUrl\n    , canGetHeaders\n\n  if (!versionSemver) {\n    // not a valid semver string, nothing we can do\n    return { version: version }\n  }\n  // flatten version into String\n  version = versionSemver.version\n\n  // nw-gyp: `overrideDistUrl` should be redirected to NW.js by default\n  if (!overrideDistUrl) {\n    overrideDistUrl = 'http://node-webkit.s3.amazonaws.com';\n  }\n\n  distBaseUrl = overrideDistUrl.replace(/\\/+$/, '')\n\n  distBaseUrl += '/v' + version + '/'\n\n  baseUrl = distBaseUrl\n  nodeLibUrl32 = resolveLibUrl('node', baseUrl, 'ia32', versionSemver.major)\n  nodeLibUrl64 = resolveLibUrl('node', baseUrl, 'x64', versionSemver.major)\n  libUrl32 = resolveLibUrl('nw', baseUrl, 'ia32', versionSemver.major)\n  libUrl64 = resolveLibUrl('nw', baseUrl, 'x64', versionSemver.major)\n\n  tarballUrl = url.resolve(baseUrl, 'nw-headers-v' + version + '.tar.gz')\n\n  return {\n    version: version,\n    semver: versionSemver,\n    name: 'nw',\n    baseUrl: baseUrl,\n    tarballUrl: tarballUrl,\n    shasumsUrl: url.resolve(baseUrl, 'SHASUMS256.txt'),\n    versionDir: version,\n    libUrl32: libUrl32,\n    libUrl64: libUrl64,\n    nodeLibUrl32: nodeLibUrl32,\n    nodeLibUrl64: nodeLibUrl64,\n    libPath32: normalizePath(path.relative(url.parse(baseUrl).path, url.parse(libUrl32).path)),\n    libPath64: normalizePath(path.relative(url.parse(baseUrl).path, url.parse(libUrl64).path)),\n    nodeLibPath32: normalizePath(path.relative(url.parse(baseUrl).path, url.parse(nodeLibUrl32).path)),\n    nodeLibPath64: normalizePath(path.relative(url.parse(baseUrl).path, url.parse(nodeLibUrl64).path))\n  }\n}\n\nfunction normalizePath (p) {\n  return path.normalize(p).replace(/\\\\/g, '/')\n}\n\nfunction resolveLibUrl (name, defaultUrl, arch, versionMajor) {\n  if (arch === 'ia32') {\n    return url.resolve(defaultUrl, name + '.lib');\n  } else {\n    return url.resolve(defaultUrl, arch + '/' + name + '.lib')\n  }\n}\n\nmodule.exports = processRelease\n","/home/travis/build/npmtest/node-npmtest-nw-gyp/node_modules/nw-gyp/lib/process-release.js":"var semver = require('semver')\n  , url = require('url')\n  , path = require('path')\n  , log = require('npmlog')\n\n    // versions where -headers.tar.gz started shipping\n  , headersTarballRange = '>= 3.0.0 || ~0.12.10 || ~0.10.42'\n  , bitsre = /\\/win-(x86|x64)\\//\n  , bitsreV3 = /\\/win-(x86|ia32|x64)\\// // io.js v3.x.x shipped with \"ia32\" but should\n                                        // have been \"x86\"\n\n// Captures all the logic required to determine download URLs, local directory and \n// file names. Inputs come from command-line switches (--target, --dist-url),\n// `process.version` and `process.release` where it exists.\nfunction processRelease (argv, gyp, defaultVersion, defaultRelease) {\n  var version = (semver.valid(argv[0]) && argv[0]) || gyp.opts.target || defaultVersion\n    , versionSemver = semver.parse(version)\n    , overrideDistUrl = gyp.opts['dist-url'] || gyp.opts.disturl\n    , isDefaultVersion\n    , isIojs\n    , name\n    , distBaseUrl\n    , baseUrl\n    , libUrl32\n    , libUrl64\n    , tarballUrl\n    , canGetHeaders\n\n  if (!versionSemver) {\n    // not a valid semver string, nothing we can do\n    return { version: version }\n  }\n  // flatten version into String\n  version = versionSemver.version\n\n  // defaultVersion should come from process.version so ought to be valid semver\n  isDefaultVersion = version === semver.parse(defaultVersion).version\n\n  // can't use process.release if we're using --target=x.y.z\n  if (!isDefaultVersion)\n    defaultRelease = null\n\n  if (defaultRelease) {\n    // v3 onward, has process.release\n    name = defaultRelease.name.replace(/io\\.js/, 'iojs') // remove the '.' for directory naming purposes\n    isIojs = name === 'iojs'\n  } else {\n    // old node or alternative --target=\n    // semver.satisfies() doesn't like prerelease tags so test major directly\n    isIojs = versionSemver.major >= 1 && versionSemver.major < 4\n    name = isIojs ? 'iojs' : 'node'\n  }\n\n  // check for the nvm.sh standard mirror env variables\n  if (!overrideDistUrl) {\n    if (isIojs) {\n      if (process.env.IOJS_ORG_MIRROR) {\n        overrideDistUrl = process.env.IOJS_ORG_MIRROR\n      } else if (process.env.NVM_IOJS_ORG_MIRROR) {// remove on next semver-major\n        overrideDistUrl = process.env.NVM_IOJS_ORG_MIRROR\n        log.warn('download',\n            'NVM_IOJS_ORG_MIRROR is deprecated and will be removed in node-gyp v4, ' +\n            'please use IOJS_ORG_MIRROR')\n      }\n    } else {\n      if (process.env.NODEJS_ORG_MIRROR) {\n        overrideDistUrl = process.env.NODEJS_ORG_MIRROR\n      } else if (process.env.NVM_NODEJS_ORG_MIRROR) {// remove on next semver-major\n        overrideDistUrl = process.env.NVM_NODEJS_ORG_MIRROR\n        log.warn('download',\n            'NVM_NODEJS_ORG_MIRROR is deprecated and will be removed in node-gyp v4, ' +\n            'please use NODEJS_ORG_MIRROR')\n      }\n    }\n  }\n\n\n  if (overrideDistUrl)\n    distBaseUrl = overrideDistUrl.replace(/\\/+$/, '')\n  else\n    distBaseUrl = isIojs ? 'https://iojs.org/download/release' : 'https://nodejs.org/dist'\n  distBaseUrl += '/v' + version + '/'\n\n  // new style, based on process.release so we have a lot of the data we need\n  if (defaultRelease && defaultRelease.headersUrl && !overrideDistUrl) {\n    baseUrl = url.resolve(defaultRelease.headersUrl, './')\n    libUrl32 = resolveLibUrl(name, defaultRelease.libUrl || baseUrl || distBaseUrl, 'x86', versionSemver.major)\n    libUrl64 = resolveLibUrl(name, defaultRelease.libUrl || baseUrl || distBaseUrl, 'x64', versionSemver.major)\n\n    return {\n      version: version,\n      semver: versionSemver,\n      name: name,\n      baseUrl: baseUrl,\n      tarballUrl: defaultRelease.headersUrl,\n      shasumsUrl: url.resolve(baseUrl, 'SHASUMS256.txt'),\n      versionDir: (name !== 'node' ? name + '-' : '') + version,\n      libUrl32: libUrl32,\n      libUrl64: libUrl64,\n      libPath32: normalizePath(path.relative(url.parse(baseUrl).path, url.parse(libUrl32).path)),\n      libPath64: normalizePath(path.relative(url.parse(baseUrl).path, url.parse(libUrl64).path))\n    }\n  }\n\n  // older versions without process.release are captured here and we have to make\n  // a lot of assumptions, additionally if you --target=x.y.z then we can't use the\n  // current process.release\n\n  baseUrl = distBaseUrl\n  libUrl32 = resolveLibUrl(name, baseUrl, 'x86', versionSemver.major)\n  libUrl64 = resolveLibUrl(name, baseUrl, 'x64', versionSemver.major)\n  // making the bold assumption that anything with a version number >3.0.0 will\n  // have a *-headers.tar.gz file in its dist location, even some frankenstein\n  // custom version\n  canGetHeaders = semver.satisfies(versionSemver, headersTarballRange)\n  tarballUrl = url.resolve(baseUrl, name + '-v' + version + (canGetHeaders ? '-headers' : '') + '.tar.gz')\n\n  return {\n    version: version,\n    semver: versionSemver,\n    name: name,\n    baseUrl: baseUrl,\n    tarballUrl: tarballUrl,\n    shasumsUrl: url.resolve(baseUrl, 'SHASUMS256.txt'),\n    versionDir: (name !== 'node' ? name + '-' : '') + version,\n    libUrl32: libUrl32,\n    libUrl64: libUrl64,\n    libPath32: normalizePath(path.relative(url.parse(baseUrl).path, url.parse(libUrl32).path)),\n    libPath64: normalizePath(path.relative(url.parse(baseUrl).path, url.parse(libUrl64).path))\n  }\n}\n\nfunction normalizePath (p) {\n  return path.normalize(p).replace(/\\\\/g, '/')\n}\n\nfunction resolveLibUrl (name, defaultUrl, arch, versionMajor) {\n  var base = url.resolve(defaultUrl, './')\n    , hasLibUrl = bitsre.test(defaultUrl) || (versionMajor === 3 && bitsreV3.test(defaultUrl))\n\n  if (!hasLibUrl) {\n    // let's assume it's a baseUrl then\n    if (versionMajor >= 1)\n      return url.resolve(base, 'win-' + arch  +'/' + name + '.lib')\n    // prior to io.js@1.0.0 32-bit node.lib lives in /, 64-bit lives in /x64/\n    return url.resolve(base, (arch === 'x64' ? 'x64/' : '') + name + '.lib')\n  }\n\n  // else we have a proper url to a .lib, just make sure it's the right arch\n  return defaultUrl.replace(versionMajor === 3 ? bitsreV3 : bitsre, '/win-' + arch + '/')\n}\n\nmodule.exports = processRelease\n","/home/travis/build/npmtest/node-npmtest-nw-gyp/node_modules/nw-gyp/lib/rebuild.js":"\nmodule.exports = exports = rebuild\n\nexports.usage = 'Runs \"clean\", \"configure\" and \"build\" all at once'\n\nfunction rebuild (gyp, argv, callback) {\n\n  gyp.todo.push(\n      { name: 'clean', args: [] }\n    , { name: 'configure', args: argv }\n    , { name: 'build', args: [] }\n  )\n  process.nextTick(callback)\n}\n","/home/travis/build/npmtest/node-npmtest-nw-gyp/node_modules/nw-gyp/lib/remove.js":"\nmodule.exports = exports = remove\n\nexports.usage = 'Removes the node development files for the specified version'\n\n/**\n * Module dependencies.\n */\n\nvar fs = require('fs')\n  , rm = require('rimraf')\n  , path = require('path')\n  , log = require('npmlog')\n  , semver = require('semver')\n\nfunction remove (gyp, argv, callback) {\n\n  var devDir = gyp.devDir\n  log.verbose('remove', 'using nw-gyp dir:', devDir)\n\n  // get the user-specified version to remove\n  var version = argv[0] || gyp.opts.target\n  log.verbose('remove', 'removing target version:', version)\n\n  if (!version) {\n    return callback(new Error('You must specify a version number to remove. Ex: \"' + process.version + '\"'))\n  }\n\n  var versionSemver = semver.parse(version)\n  if (versionSemver) {\n    // flatten the version Array into a String\n    version = versionSemver.version\n  }\n\n  var versionPath = path.resolve(gyp.devDir, version)\n  log.verbose('remove', 'removing development files for version:', version)\n\n  // first check if its even installed\n  fs.stat(versionPath, function (err, stat) {\n    if (err) {\n      if (err.code == 'ENOENT') {\n        callback(null, 'version was already uninstalled: ' + version)\n      } else {\n        callback(err)\n      }\n      return\n    }\n    // Go ahead and delete the dir\n    rm(versionPath, callback)\n  })\n\n}\n"}